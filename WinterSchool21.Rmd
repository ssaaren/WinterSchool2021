---
title: "Spatial Transcriptomics for Winter School"
author: "Sami"
date: "1/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/GitHub/WinterSchool2021/")
```

#Spatial Transcriptomics -- workshop for Visium data analysis
Welcome to the Spatial Transcriptomics workshop! 
It is based on a previous workshop of Alma Andersson, the same one who developed the single-cell and spatial data integration tool, Stereoscope and the materials from the publication of Bergenstråhle et al. (2020) and https://ludvigla.github.io/STUtility_web_site/.

#Introduction
We will explore the field of Spatial Transcriptomics. Many of the ideas that you encountered when working with single cell data will be revistied but now with the advantage that we can visualize our results in the real physical space (not just UMAP or tSNE space). 

The field of spatial transcriptomics has grown rapidly, and multiple techniques to obtain information of spatial gene expression exists. Some examples are : MERFISH, ISS, osmFISH, seqFISH, HDST, baristaSeq, Slide-seq, and GeoMx. We will however be focusing on spatial data generated from the _Visium_ platform (sold by 10x Genomics). Visium is the successor to the technique - somewhat
confusingly - named Spatial Transcriptomics (commonly referred to as ST).

ST was developed at SciLifeLab and presented to the world in 2016 when the publication _Visualization and analysis of gene expression in tissue sections by spatial transcriptomics_  was published in the journal Science. In December2018, 10x Genomics aquired the IP rights to the ST-technique, they then launched the Visium platform in late 2019.

Both ST and Visium utilize a solid array onto which oligonucleotides with spatial barcodes have been printed at locations (spots) arranged in a regular grid. These oligonucleotides all have a poly-T sequence, making them apt to capture mRNA's by their poly-A tail. By reverse transcription, the barcodes of the oligonucleotides will be embedded in cDNA synthesized from the captured mRNA's; hence, we know at which mRNA that each transcript was captured. Once the cDNA molecules are sequenced, we can backmap them to their spatial position - using the barcodes - and by doing so obtain spatial gene expression information. The "old" ST arrays had 1000 spots printed on the array, while the newer Visium slides has 5000 spots.

One *key* fact that should be emphasized is how none of these methods (ST and Visium) operate on a single cell level yet. The gene expression data associated with each spot is really *a mixture of contributions from multiple cells*, not all necessarliy of the same cell type.

##Install packages

To analyse the gene count matrices, we will use a package called STUtility. It was published 2020 by Bergenstråhle et al. 
STUtility is based on Seurat, single-cell analysis tool, of which most of you probably have heard before. 
In addition, STUtility depends on plethora of other packages, so installing all the packages from the scratch will take some time. 
This code below checks that all the packages are installed and **should** install the ones missing. 
```{r, echo = FALSE, eval = TRUE}
# This chunk will:
# 1. Check if a package is installed
# 2. Install the package if it's missing
# 3. load the package

load.pkgs <- c("Seurat" = "cran",
               "sctransform"="cran",
               "ggplot2"="cran",
               "png"="cran",
               "grid"="cran",
               "topicmodels"="cran",
               "gridExtra" = "cran",
               "tm" = "cran",
               "gridExtra" = "cran",
               "dplyr" = "cran",
               "RColorBrewer"="cran",
               "hdf5r"="cran"
               )

installed.pkgs <- installed.packages()[,1]

for (pkg in names(load.pkgs) ) {
  if (!(pkg %in% installed.pkgs) ) {
    print(sprintf("Installing : %s",pkg))
    if (load.pkgs[pkg] == "cran") {
      install.packages(pkg)
    } else if (load.pkgs[pkg] == "bioc") {
          BiocManager::install(pkg)
    }
  }
  do.call("library",list(pkg))
}
library(STutility)
```

First things first: let's discuss about the data. For this tutorial we will use publicly available data from 10x Genomics Inc. We study two sagittal sections from mouse brain. 
WinterSchool2021 we have several different files. We start with raw data. Raw data is unfiltered and contains the data from all the spots, also outside of the tissue. It includes also all the mitochondrial genes but let's get back to that a bit later. 

First, let's creat a Seurat object. For that we need .h5 files which are compact gene count matrices, spotfiles which contain the positions of the tissue, imgs as bright field images from the tissue and json files as the spot coordinates. 
In addition, we can add sample  specific metadata, like section number or slide number. 

We load all this to the object using InputFromTable command:

#Lateral diffusion
```{r}
#Collect file paths and metadata
samples <- list.files(path = "~/Documents/GitHub/WinterSchool2021", pattern = "raw_feature_bc_matrix.h5", recursive = TRUE, full.names = T)
spotfiles <- list.files(path = "~/Documents/GitHub/WinterSchool2021", pattern = ".csv", full.names = T)
imgs <- list.files(path = "~/Documents/GitHub/WinterSchool2021", pattern = "hires_image.png", recursive = T,full.names = T)
json <- list.files(path = "~/Documents/GitHub/WinterSchool2021", pattern = "json.json", full.names = T)
section <- c("1", "2")
slide <- c("V19L29-035", "V19L29-035")

#Create table for the metadata
infoTable <- data.frame(samples, imgs,spotfiles,json, section, slide, stringsAsFactors = F)

#Load the data based on infoTable
se <- InputFromTable(infotable = infoTable,
                     disable.subset = T)



```

We can filter out some spots and genes are not meaningfull for the analysis. Commonly these genes have too low expression or they are expressed in only couple of spots. But how to choose what is good amount filtering? 

Try yourself and use ST.Featureplots and Vlnplots to visualise what happens in every situation. 

```{r}
ST.FeaturePlot(se, features = c("nFeature_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))
ST.FeaturePlot(se, features = c("nCount_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))
```
Next, let's look at the ribosomal and mitochondrial gene expression patterns on tissue level. 
We will 
```{r}
mt.genes <- grep(pattern = "^mt-", x = rownames(se), value = TRUE)
se$percent.mito <- (Matrix::colSums(se@assays$RNA@counts[mt.genes, ])/Matrix::colSums(se@assays$RNA@counts))*100
rp.genes <- grep(pattern = "^Rpl|^Rps", x = rownames(se), value = TRUE)
se$percent.ribo <- (Matrix::colSums(se@assays$RNA@counts[rp.genes, ])/Matrix::colSums(se@assays$RNA@counts))*100
ST.FeaturePlot(se, features = "percent.mito", dark.theme = TRUE, cols = c("dark blue", "cyan", "yellow", "red", "dark red"))
ST.FeaturePlot(se, features = "percent.ribo", dark.theme = TRUE, cols = c("dark blue", "cyan", "yellow", "red", "dark red"))

VlnPlot(se, features = c("nFeature_RNA", "nCount_RNA", "percent.mito", "percent.ribo"), ncol = 4) 
```
#Spots under the tissue

```{r}

#Load the data based on infoTable
se.tissue <- InputFromTable(infotable = infoTable)

#Load images to the object
system.time({se.tissue <- LoadImages(object = se.tissue, verbose = T)})

```
We can visualise the distribution of the unique molecules and unique genes to help with the filtering. 

```{r}
p1 <- ggplot() +
  geom_histogram(data = se.tissue[[]], aes(nFeature_RNA), fill = "brown", alpha = 0.7, color = "gray", bins = 50) +
  ggtitle("Unique genes per spot")

p2 <- ggplot() +
  geom_histogram(data = se.tissue[[]], aes(nCount_RNA), fill = "brown", alpha = 0.7, color = "gray", bins = 50) +
  ggtitle("Total counts per spots")

gene_attr <- data.frame(nUMI = Matrix::rowSums(se.tissue@assays$RNA@counts), 
                        nSpots = Matrix::rowSums(se.tissue@assays$RNA@counts > 0))
p3 <- ggplot() +
  geom_histogram(data = gene_attr, aes(nUMI), fill = "brown", alpha = 0.7, color = "gray", bins = 50) +
  scale_x_log10() +
  ggtitle("Total counts per gene (log10 scale)")

p4 <- ggplot() +
  geom_histogram(data = gene_attr, aes(nSpots), fill = "brown", alpha = 0.7, color = "gray", bins = 50) +
  ggtitle("Total spots per gene")

cowplot::plot_grid(p1, p2, p3, p4)
```
```{r}
mt.genes <- grep(pattern = "^mt-", x = rownames(se.tissue), value = TRUE)
se.tissue$percent.mito <- (Matrix::colSums(se.tissue@assays$RNA@counts[mt.genes, ])/Matrix::colSums(se.tissue@assays$RNA@counts))*100
rp.genes <- grep(pattern = "^Rpl|^Rps", x = rownames(se.tissue), value = TRUE)
se.tissue$percent.ribo <- (Matrix::colSums(se.tissue@assays$RNA@counts[rp.genes, ])/Matrix::colSums(se.tissue@assays$RNA@counts))*100
ST.FeaturePlot(se.tissue, features = "percent.mito", dark.theme = TRUE, cols = c("dark blue", "cyan", "yellow", "red", "dark red"))
ST.FeaturePlot(se.tissue, features = "percent.ribo", dark.theme = TRUE, cols = c("dark blue", "cyan", "yellow", "red", "dark red"))

VlnPlot(se.tissue, features = c("nFeature_RNA", "nCount_RNA", "percent.mito", "percent.ribo"), ncol = 4, pt.size = 0.05) 
```
#Filtering
```{r}
se.subset <- SubsetSTData(se.tissue, expression = nFeature_RNA > 500 & percent.mito < 30)


ST.FeaturePlot(se.subset, features = c("nFeature_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))
ST.FeaturePlot(se.subset, features = c("nCount_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))

```


#Keeping only protein-coding genes
```{r}
ensids <- read.table(file = "mouse_genes.tsv", header = T, sep = "\t", stringsAsFactors = F)

# Print available biotypes
unique(ensids$gene_type)
keep.genes <- subset(ensids, gene_type %in% "protein_coding")$gene_name

# Subset Seurat object
se.subset <- se.subset[intersect(rownames(se.subset), keep.genes), ]

ST.FeaturePlot(se.subset, features = c("nFeature_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))
ST.FeaturePlot(se.subset, features = c("nCount_RNA"), dark.theme = T, cols = c("black", "darkblue", "cyan", "yellow", "red", "darkred"))

```
#Image processing

```{r}

#Load images to the object
system.time({se.subset <- LoadImages(object = se.subset, verbose = T)})

ImagePlot(se.subset, method = "raster", darken = TRUE, type = "raw")

ST.FeaturePlot(object = se.subset, 
               features = c("nFeature_RNA"), 
               cols = c("dark blue", "cyan", "yellow", "red", "dark red"),
               ncol = 2, 
               grid.ncol = 1, 
               dark.theme = T)

FeatureOverlay(se.subset, 
               features = "Cck", 
               pt.size = 1.5,
               cols = c("dark blue", "cyan", "yellow", "red", "dark red"), 
               dark.theme = T, 
               type = "raw")

```
#Masking and alignment

```{r}

se.subset <- se.subset %>% MaskImages(channels.use = 2) %>% AlignImages()
ImagePlot(se.subset, ncols = 2, method = "raster", type = "masked", darken = T)
ImagePlot(se.subset, method = "raster", darken = TRUE, type = "processed", ncols = 2)

```
##Normalization

We normalize our data using SCTransformm here but Harmony is another normalisation technique that is widely used in the lab.
SCtransform is an alternative to NormalizeData, FindVariableFeatures and ScaleData.
What do you see here?
Output format: Results in new SCT assay, counts corrected, log1p(counts) as data.

Possible batch effects check:-
Batch effects can bring unexplanable or even biased biological variations in the data.
  - Arise from multiple reasons, like different samples, storage times, different slides or different arrays within the same     slide
  - vars.to.regress option from the SCTransform removes these batch effects. We can state which batches to choose in this       option.
Make sure this 'batch' information is available in the meta.data before proceeding.

```{r}
#Default normalisation without any batch effects correction
se.subset <- SCTransform(se.subset)

#SCTransform with batch effect correction using 'section' and 'nFeature_RNA'
se.batch.section.cor <- SCTransform(se.subset, vars.to.regress = c("section", "nFeature_RNA"))

```

##Factor Analysis and Dimensionality reduction techniques

We can use factor analysis along with a variety of reduction techniques to fish out patterns of transcriptomic profiles.

Try with different combinations of nfactors and RUNXXX and see what happens.
nfactors = c(20,30)
RUNXXX <- PCA, TSNE, ICA, UMAP

```{r}
se.subset <- RunNMF(se.subset, nfactors = 10)

cscale <- c("darkblue", "cyan", "yellow", "red", "darkred")

#Plot variable number of dimensions across the samples
ST.DimPlot(se.subset, 
           dims = 1:10,
           ncol = 2, # dimension level column setting
           grid.ncol = 2, # Sample level column setting
           reduction = "NMF",
           pt.size = 1, 
           center.zero = F, 
           cols = cscale)


#Print summary of most contributing genes
print(se.subset[["NMF"]])

#Barplot of the most contributing genes
FactorGeneLoadingPlot(se.subset, factor = 3, dark.theme = TRUE)
```

We can also view the most variable features/genes.

```{r}
head(se.subset@assays$SCT@var.features, 10)

most.var.genes <- se.subset@assays$SCT@var.features

fts <- c("Ttr", "Hba-a1", "Ptgds")
for (ftr in fts) {
  p <- FeatureOverlay(se.subset, 
                  features = ftr, 
                  sampleids = 1:2,
                  cols = c("darkblue", "cyan", "yellow", "red", "darkred"),
                  pt.size = 1.5, 
                  pt.alpha = 0.5, 
                  dark.theme = T, 
                  ncols.samples = 2)
                  print(p)
}
```

Below is a UMAP embedding to compare the spatial distribution of a gene.
Try with t-SNE embedding

```{r}
se.subset <- RunUMAP(se.subset, reduction = "NMF", dims = 1:10, n.neighbors = 10)

#Gene list for plotting
fts <- c("Ttr", "Hba-a1", "Ptgds")

# Plot code for gene expression on visium coordinates
p3 <- ST.FeaturePlot(se.subset, features = fts, ncol = 2, grid.ncol = 1, pt.size = 1, show.sb = FALSE)
cowplot::plot_grid(p3, ncol = 2)

# Plot code for gene expression on UMAP embedding
p.fts <- lapply(fts, function(ftr) {
  FeaturePlot(se.subset, features = ftr, reduction = "umap", order = TRUE)
})
cowplot::plot_grid(plotlist = p.fts, ncol = 2)
```


##Clustering 

An important part of Genome Analysis, we will use the most 'spatially' contributing dimensions from factor analysis in clustering.

Try with reduction = c(PCA, UMAP)

```{r}
#construct Shared Nearest Neighbor (SSN) graph
se.subset <- FindNeighbors(object = se.subset, verbose = FALSE, reduction = "NMF", dims = 1:10)

se.subset <- FindClusters(object = se.subset, verbose = FALSE)

library(RColorBrewer)
n <- 19
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

ST.FeaturePlot(object = se.subset, features = "seurat_clusters", dark.theme = T, cols = col_vector, pt.size = 1)
```

If clusters seem cluttered, then view each cluster using 'split.labels = T' but for only one section at a time.

Try with indices = 2, for section 2/sample 2

```{r}
ST.FeaturePlot(object = se.subset, features = "seurat_clusters", pt.size = 1, split.labels = T, indices = 1, show.sb = FALSE)
```

##Differential Expression Analysis (DEA)

We can look at the most differentially expressed genes across the tissue, also termed here as Markers.

ident.1 selects the cluster ID/number where we want to look at the differentially expressed genes/markers.

Try with other clusters as well.

```{r}
diff.genes <- FindMarkers(se.subset, ident.1 = 1) #this step will take a couple of minutes to finish
head(diff.genes)
```

We can also look at the expression of one gene of interest across the 'rest' of the samples by using FeatureOverlay.

Try with other genes.

```{r}
FeatureOverlay(se.subset, features = "Nrgn", 
              sampleids = 1:2,
              cols = c("darkblue", "cyan", "yellow", "red", "darkred"),
              pt.size = 1.5, 
              pt.alpha = 0.5,
              ncols.samples = 2)
```

##Spatial Autocorrection

We can find genes with spatial patterns across the tissue. STUtility uses neighborhood networks to provide an overall expression of a gene relative to it neighborhood. Each gene's orginal expression and this new relative expression is calculated. All genes are then further ranked based on this dataframe of gene expression vectors.

```{r}
library(spdep)
neigh.genes <- CorSpatialGenes(se.subset)
```

View a summary of the neigh.genes

```{r}
head(neigh.genes)
```




